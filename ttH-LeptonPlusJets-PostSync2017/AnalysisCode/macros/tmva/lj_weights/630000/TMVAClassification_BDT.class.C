// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.1.2         [262402]
ROOT Release   : 5.32/00       [335872]
Creator        : gsmith
Date           : Fri Jun 21 12:56:53 2013
Host           : Linux lxbuild167.cern.ch 2.6.18-308.1.1.el5 #1 SMP Wed Mar 7 19:25:07 CET 2012 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /home/gsmith/cms_work/CMSSW_5_2_6/src/AnalysisCode/LeptonPlusJets/macros/tmva
Training events: 6196
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
BoostType: "Grad" [Boosting type for the trees in the forest]
UseBaggedGrad: "False" [Use only a random subsample of all events for growing the trees in each iteration. (Only valid for GradBoost)]
Shrinkage: "1.000000e-01" [Learning rate for GradBoost algorithm]
nCuts: "20" [Number of steps during node cut optimisation]
NNodesMax: "5" [Max number of nodes in tree]
NegWeightTreatment: "ignorenegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : Ignore;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!); Randomly pair events with negative and positive weights in leaf node and do not boost them (experimental!) ]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
RenormByClass: "False" [Individually re-normalize each event class to the original size after boosting]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2t (Linear,Quadratic or Exponential)]
GradBaggingFraction: "6.000000e-01" [Defines the fraction of events to be used in each iteration when UseBaggedGrad=kTRUE. (Only valid for GradBoost)]
AdaBoostBeta: "1.000000e+00" [Parameter for AdaBoost algorithm]
UseRandomisedTrees: "False" [Choose at each node splitting a random set of variables]
UseNvars: "4" [Number of variables used if randomised tree option is chosen]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split]
UseNTrainEvents: "6196" [Number of randomly picked training events used in randomised (and bagged) trees]
UseWeightedTrees: "True" [Use weighted trees or simple average in classification from the forest]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
SeparationType: "giniindex" [Separation criterion for node splitting]
nEventsMin: "40" [Minimum number of events required in a leaf node (default: Classification: max(40, N_train/(Nvar^2)/10), Regression: 10)]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
PruneStrength: "0.000000e+00" [Pruning strength]
PruneMethod: "nopruning" [Method used for pruning (removal) of statistically insignificant branches]
PruneBeforeBoost: "False" [Flag to prune the tree before applying boosting algorithm]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
MaxDepth: "3" [Max depth of the decision tree allowed]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 15
sphericity                    sphericity                    sphericity                    sphericity                    sphericity                        'F'    [0.0330610834062,0.915650188923]
h3                            h3                            h3                            h3                            h3                                'F'    [0.000233534374274,0.948978185654]
maxeta_jet_jet                maxeta_jet_jet                maxeta_jet_jet                maxeta_jet_jet                maxeta_jet_jet                    'F'    [0.443231105804,4.38394451141]
maxeta_jet_tag                maxeta_jet_tag                maxeta_jet_tag                maxeta_jet_tag                maxeta_jet_tag                    'F'    [0.0392142795026,4.09495544434]
maxeta_tag_tag                maxeta_tag_tag                maxeta_tag_tag                maxeta_tag_tag                maxeta_tag_tag                    'F'    [0.0656469091773,5.27989292145]
abs(dEta_leptop_bb)           abs_dEta_leptop_bb_           abs(dEta_leptop_bb)           abs_dEta_leptop_bb            abs_dEta_leptop_bb                'F'    [4.82857940369e-05,8.89074516296]
abs(dEta_hadtop_bb)           abs_dEta_hadtop_bb_           abs(dEta_hadtop_bb)           abs_dEta_hadtop_bb            abs_dEta_hadtop_bb                'F'    [0.000172531654243,7.84265899658]
dEta_fn                       dEta_fn                       dEta_fn                       dEta_fn                       dEta_fn                           'F'    [0.0032690349035,8.350274086]
M3                            M3                            M3                            M3                            M3                                'F'    [70.6875762939,1687.96972656]
min_dr_tagged_jets            min_dr_tagged_jets            min_dr_tagged_jets            min_dr_tagged_jets            min_dr_tagged_jets                'F'    [0.503497004509,3.36406707764]
pt_all_jets_over_E_all_jets   pt_all_jets_over_E_all_jets   pt_all_jets_over_E_all_jets   pt_all_jets_over_E_all_jets   pt_all_jets_over_E_all_jets       'F'    [0.262307077646,0.962321996689]
aplanarity                    aplanarity                    aplanarity                    aplanarity                    aplanarity                        'F'    [0.00263623520732,0.417841851711]
h1                            h1                            h1                            h1                            h1                                'F'    [-0.176403835416,0.35075044632]
tagged_dijet_mass_closest_to_125 tagged_dijet_mass_closest_to_125 tagged_dijet_mass_closest_to_125 tagged_dijet_mass_closest_to_125 tagged_dijet_mass_closest_to_125     'F'    [0,223.909973145]
third_jet_pt                  third_jet_pt                  third_jet_pt                  third_jet_pt                  third_jet_pt                      'F'    [32.6414909363,397.257232666]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 15 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "sphericity", "h3", "maxeta_jet_jet", "maxeta_jet_tag", "maxeta_tag_tag", "abs(dEta_leptop_bb)", "abs(dEta_hadtop_bb)", "dEta_fn", "M3", "min_dr_tagged_jets", "pt_all_jets_over_E_all_jets", "aplanarity", "h1", "tagged_dijet_mass_closest_to_125", "third_jet_pt" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0.0330610834062099;
      fVmax[0] = 0.915650188922882;
      fVmin[1] = 0.000233534374274313;
      fVmax[1] = 0.948978185653687;
      fVmin[2] = 0.443231105804443;
      fVmax[2] = 4.38394451141357;
      fVmin[3] = 0.0392142795026302;
      fVmax[3] = 4.09495544433594;
      fVmin[4] = 0.0656469091773033;
      fVmax[4] = 5.27989292144775;
      fVmin[5] = 4.82857940369286e-05;
      fVmax[5] = 8.89074516296387;
      fVmin[6] = 0.000172531654243357;
      fVmax[6] = 7.84265899658203;
      fVmin[7] = 0.0032690349034965;
      fVmax[7] = 8.35027408599854;
      fVmin[8] = 70.6875762939453;
      fVmax[8] = 1687.9697265625;
      fVmin[9] = 0.503497004508972;
      fVmax[9] = 3.36406707763672;
      fVmin[10] = 0.262307077646255;
      fVmax[10] = 0.962321996688843;
      fVmin[11] = 0.00263623520731926;
      fVmax[11] = 0.417841851711273;
      fVmin[12] = -0.17640383541584;
      fVmax[12] = 0.35075044631958;
      fVmin[13] = 0;
      fVmax[13] = 223.909973144531;
      fVmin[14] = 32.6414909362793;
      fVmax[14] = 397.257232666016;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';
      fType[10] = 'F';
      fType[11] = 'F';
      fType[12] = 'F';
      fType[13] = 'F';
      fType[14] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[15];
   double fVmax[15];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[15];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += current->GetResponse();
   }
   return 2.0/(1.0+exp(-2.0*myMVA))-1.0;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.53125,0.00625) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.597701,0.0195402) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.303769,-0.0392461) , 
1, 0.216387, 1, 0, 0.351301,-0.148699) , 
4, 2.54862, 1, 0, 0.5,0)    );
  // itree = 1
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.52803,0.00549858) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.543624,0.00862442) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.298566,-0.0395405) , 
11, 0.152837, 0, 0, 0.338428,-0.158447) , 
7, 1.99065, 1, 0, 0.5,-1.39153e-06)    );
  // itree = 2
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.553032,0.00985644) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.50328,0.000756898) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.354257,-0.0272357) , 
10, 0.620716, 0, 0, 0.419079,-0.0751879) , 
7, 1.1957, 1, 0, 0.5,-3.22731e-06)    );
  // itree = 3
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.53125,0.00540787) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.597701,0.0170742) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.303769,-0.0341054) , 
1, 0.216387, 1, 0, 0.351301,-0.128609) , 
4, 2.54862, 1, 0, 0.5,-4.95143e-06)    );
  // itree = 4
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.625917,0.0230034) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.576064,0.0134815) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.403691,-0.0173833) , 
10, 0.69565, 0, 0, 0.468907,-0.0283885) , 
1, 0.180947, 1, 0, 0.5,-9.57647e-06)    );
  // itree = 5
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.53748,0.00673629) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.45447,-0.00883034) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.286792,-0.0370452) , 
3, 1.86986, 1, 0, 0.403011,-0.0869604) , 
8, 301.728, 1, 0, 0.5,-8.3386e-06)    );
  // itree = 6
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.52803,0.00428679) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.543624,0.00848748) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.298566,-0.0314616) , 
11, 0.152837, 0, 0, 0.338428,-0.123327) , 
7, 1.99065, 1, 0, 0.5,-1.1472e-05)    );
  // itree = 7
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.625917,0.0200699) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.559322,0.00901048) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.39093,-0.0170765) , 
10, 0.662316, 0, 0, 0.468907,-0.0247158) , 
1, 0.180947, 1, 0, 0.5,-1.63419e-05)    );
  // itree = 8
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.537304,0.00537698) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.53869,0.00440226) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.334501,-0.0238052) , 
1, 0.258188, 1, 0, 0.38092,-0.0855723) , 
4, 2.30032, 1, 0, 0.5,-1.52373e-05)    );
  // itree = 9
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.526063,0.00402541) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.404463,-0.0142208) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.260714,-0.0390022) , 
9, 1.86116, 1, 0, 0.364092,-0.10442) , 
8, 378.741, 1, 0, 0.5,-1.874e-05)    );
  // itree = 10
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.54966,0.00703171) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.487562,-0.00195109) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.349656,-0.0213725) , 
10, 0.582434, 0, 0, 0.419831,-0.0565007) , 
6, 1.49398, 1, 0, 0.5,-2.09733e-05)    );
  // itree = 11
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.539111,0.00550496) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.573446,0.0122823) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.364448,-0.0198058) , 
11, 0.152837, 0, 0, 0.405301,-0.0663098) , 
5, 1.69351, 1, 0, 0.5,-2.24201e-05)    );
  // itree = 12
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.625917,0.0168463) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.576064,0.00939287) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.403691,-0.0124948) , 
10, 0.69565, 0, 0, 0.468907,-0.0206486) , 
1, 0.180947, 1, 0, 0.5,-2.34331e-05)    );
  // itree = 13
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.53125,0.00364339) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.557522,0.00709193) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.296471,-0.0245602) , 
1, 0.259034, 1, 0, 0.351301,-0.0861384) , 
4, 2.54862, 1, 0, 0.5,-2.05027e-05)    );
  // itree = 14
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.510046,0.00200058) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.5375,-0.00325921) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.290102,-0.0389934) , 
1, 0.164633, 1, 0, 0.343164,-0.154531) , 
14, 50.0041, 0, 0, 0.5,-2.52348e-05)    );
  // itree = 15
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.515032,0.00259613) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.416495,-0.0155905) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.146341,-0.0583553) , 
6, 2.24827, 1, 0, 0.361842,-0.11804) , 
13, 85.299, 0, 0, 0.5,-2.43199e-05)    );
  // itree = 16
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.53748,0.00477775) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.425303,-0.00868195) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.26556,-0.0363925) , 
13, 85.1269, 0, 0, 0.403011,-0.0612181) , 
8, 301.728, 1, 0, 0.5,-2.71583e-05)    );
  // itree = 17
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.553032,0.00588399) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.497482,0.00142225) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.365753,-0.0163732) , 
11, 0.102839, 0, 0, 0.419079,-0.0445264) , 
7, 1.1957, 1, 0, 0.5,-2.77982e-05)    );
  // itree = 18
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.510046,0.00182541) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.433962,-0.00650802) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.307116,-0.0373963) , 
9, 1.66445, 0, 0, 0.343164,-0.140719) , 
14, 50.0041, 0, 0, 0.5,-2.78882e-05)    );
  // itree = 19
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.681592,0.0268514) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.549009,0.00562297) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.383904,-0.0146631) , 
10, 0.595648, 0, 0, 0.487401,-0.00920854) , 
12, 0.200135, 0, 0, 0.5,-2.59323e-05)    );
  // itree = 20
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.537304,0.00382413) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.457278,-0.00203015) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.323877,-0.0206678) , 
11, 0.0991476, 0, 0, 0.38092,-0.0604587) , 
4, 2.30032, 1, 0, 0.5,-2.37573e-05)    );
  // itree = 21
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.619048,0.0158813) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.540385,0.00349633) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.354083,-0.0160656) , 
10, 0.595648, 0, 0, 0.478011,-0.0144605) , 
12, 0.124827, 0, 0, 0.5,-2.54836e-05)    );
  // itree = 22
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.510046,0.00164707) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.433962,-0.0052357) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.307116,-0.0340992) , 
9, 1.66445, 0, 0, 0.343164,-0.126403) , 
14, 50.0041, 0, 0, 0.5,-2.58924e-05)    );
  // itree = 23
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.515032,0.00213811) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.57377,0.0084169) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.308642,-0.0274089) , 
1, 0.233328, 1, 0, 0.361842,-0.0966366) , 
13, 85.299, 0, 0, 0.5,-2.47511e-05)    );
  // itree = 24
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.635338,0.016695) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.570362,0.00863896) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.431857,-0.00845713) , 
12, 0.0495194, 0, 0, 0.479993,-0.012208) , 
10, 0.795652, 0, 0, 0.5,-2.55788e-05)    );
  // itree = 25
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.516414,0.00295042) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.625,0.0170901) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.400404,-0.0173403) , 
3, 0.760868, 1, 0, 0.424707,-0.0662797) , 
13, 149.273, 1, 0, 0.5,-2.14263e-05)    );
  // itree = 26
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.539111,0.00393391) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.573446,0.00999116) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.364448,-0.0146728) , 
11, 0.152837, 0, 0, 0.405301,-0.0468839) , 
5, 1.69351, 1, 0, 0.5,-1.97592e-05)    );
  // itree = 27
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.510046,0.0015015) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.5375,-0.000663051) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.290102,-0.0301489) , 
1, 0.164633, 1, 0, 0.343164,-0.114785) , 
14, 50.0041, 0, 0, 0.5,-2.04953e-05)    );
  // itree = 28
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.53563,0.00402972) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.677966,0.0222406) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.387921,-0.0131916) , 
12, 0.200135, 0, 0, 0.422881,-0.0428346) , 
0, 0.327257, 0, 0, 0.5,-2.1156e-05)    );
  // itree = 29
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.515032,0.00193023) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.416495,-0.0111784) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.146341,-0.0481426) , 
6, 2.24827, 1, 0, 0.361842,-0.086839) , 
13, 85.299, 0, 0, 0.5,-1.97126e-05)    );
  // itree = 30
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.516414,0.0027006) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.625,0.0147294) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.400404,-0.0157637) , 
3, 0.760868, 1, 0, 0.424707,-0.0604725) , 
13, 149.273, 1, 0, 0.5,-2.35607e-05)    );
  // itree = 31
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.649934,0.0153579) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.635561,0.0143727) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.452432,-0.00498283) , 
10, 0.795652, 0, 0, 0.479132,-0.010426) , 
1, 0.135768, 1, 0, 0.5,-2.18315e-05)    );
  // itree = 32
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.514756,0.00139032) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.44898,0.00961239) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.238245,-0.0290212) , 
8, 159.655, 1, 0, 0.266304,-0.107753) , 
4, 3.29351, 1, 0, 0.5,-1.61372e-05)    );
  // itree = 33
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.510046,0.0013734) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.433962,-0.00196669) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.307116,-0.0296463) , 
9, 1.66445, 0, 0, 0.343164,-0.104546) , 
14, 50.0041, 0, 0, 0.5,-1.95759e-05)    );
  // itree = 34
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.53748,0.00339853) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.435019,-0.00420806) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.309955,-0.02313) , 
13, 106.409, 0, 0, 0.403011,-0.0429616) , 
8, 301.728, 1, 0, 0.5,-1.94518e-05)    );
  // itree = 35
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.506513,0.000981565) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.338462,-0.00604228) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.300699,-0.0383441) , 
4, 2.60649, 0, 0, 0.3125,-0.137763) , 
13, 191.923, 1, 0, 0.5,-2.02521e-05)    );
  // itree = 36
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.702041,0.02535) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.619048,0.0119535) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.467001,-0.00357358) , 
12, 0.124827, 0, 0, 0.491682,-0.00509782) , 
10, 0.86232, 0, 0, 0.5,-1.88194e-05)    );
  // itree = 37
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.53563,0.00349761) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.561279,0.00857732) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.367025,-0.0144979) , 
6, 0.75056, 1, 0, 0.422881,-0.0369822) , 
0, 0.327257, 0, 0, 0.5,-1.36887e-05)    );
  // itree = 38
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.515032,0.00167558) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.416495,-0.00978563) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.146341,-0.0432605) , 
6, 2.24827, 1, 0, 0.361842,-0.0749445) , 
13, 85.299, 0, 0, 0.5,-1.47618e-05)    );
  // itree = 39
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.516414,0.00236735) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.576764,0.00495451) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.382488,-0.0154098) , 
10, 0.737512, 0, 0, 0.424707,-0.0526634) , 
13, 149.273, 1, 0, 0.5,-1.86349e-05)    );
  // itree = 40
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.510046,0.0012723) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.433962,-0.00213261) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.307116,-0.0274521) , 
9, 1.66445, 0, 0, 0.343164,-0.0964326) , 
14, 50.0041, 0, 0, 0.5,-1.80366e-05)    );
  // itree = 41
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.539111,0.00313273) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.573446,0.00820558) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.364448,-0.0118695) , 
11, 0.152837, 0, 0, 0.405301,-0.0370333) , 
5, 1.69351, 1, 0, 0.5,-1.81003e-05)    );
  // itree = 42
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.649934,0.012726) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.542367,0.00350461) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.412188,-0.00750194) , 
3, 1.39113, 1, 0, 0.479132,-0.00854272) , 
1, 0.135768, 1, 0, 0.5,-1.83257e-05)    );
  // itree = 43
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.515032,0.00151373) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.52518,0.00571328) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.313433,-0.0207302) , 
12, 0.0678503, 0, 0, 0.361842,-0.0675061) , 
13, 85.299, 0, 0, 0.5,-1.57408e-05)    );
  // itree = 44
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.516414,0.00215186) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.625,0.0119396) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.400404,-0.0126107) , 
3, 0.760868, 1, 0, 0.424707,-0.0476981) , 
13, 149.273, 1, 0, 0.5,-1.66494e-05)    );
  // itree = 45
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.510046,0.00116153) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.433962,-0.00178103) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.307116,-0.0252773) , 
9, 1.66445, 0, 0, 0.343164,-0.087714) , 
14, 50.0041, 0, 0, 0.5,-1.56664e-05)    );
  // itree = 46
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.681592,0.0175787) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.549009,0.00347064) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.383904,-0.00934567) , 
10, 0.595648, 0, 0, 0.487401,-0.00582279) , 
12, 0.200135, 0, 0, 0.5,-1.59195e-05)    );
  // itree = 47
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.514756,0.0010984) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.44898,0.0106222) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.238245,-0.0241853) , 
8, 159.655, 1, 0, 0.266304,-0.0843658) , 
4, 3.29351, 1, 0, 0.5,-1.41433e-05)    );
  // itree = 48
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.526063,0.00188285) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.404463,-0.00522196) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.260714,-0.0235922) , 
9, 1.86116, 1, 0, 0.364092,-0.0475268) , 
8, 378.741, 1, 0, 0.5,-1.66852e-05)    );
  // itree = 49
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.702041,0.0211964) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.570825,0.0060339) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.454792,-0.00410326) , 
12, 0.0495194, 0, 0, 0.491682,-0.0041901) , 
10, 0.86232, 0, 0, 0.5,-1.80148e-05)    );
  // itree = 50
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.510046,0.00106094) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.433962,-0.00131601) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.307116,-0.0233369) , 
9, 1.66445, 0, 0, 0.343164,-0.079789) , 
14, 50.0041, 0, 0, 0.5,-1.4227e-05)    );
  // itree = 51
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.506513,0.000782301) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.338462,0.00045927) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.300699,-0.0328881) , 
4, 2.60649, 0, 0, 0.3125,-0.10852) , 
13, 191.923, 1, 0, 0.5,-1.45303e-05)    );
  // itree = 52
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.53563,0.00280818) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.561279,0.00742392) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.367025,-0.0119739) , 
6, 0.75056, 1, 0, 0.422881,-0.0294538) , 
0, 0.327257, 0, 0, 0.5,-1.411e-05)    );
  // itree = 53
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.515032,0.001353) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.416495,-0.0077326) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.146341,-0.0378414) , 
6, 2.24827, 1, 0, 0.361842,-0.059972) , 
13, 85.299, 0, 0, 0.5,-1.45769e-05)    );
  // itree = 54
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.550725,0.0138505) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.532743,0.00129599) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.383966,-0.00884704) , 
8, 301.728, 1, 0, 0.495712,-0.00563062) , 
14, 136.817, 0, 0, 0.5,-1.75859e-05)    );
  // itree = 55
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.516414,0.00186271) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.576764,0.00390321) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.382488,-0.0122135) , 
10, 0.737512, 0, 0, 0.424707,-0.0410138) , 
13, 149.273, 1, 0, 0.5,-1.70725e-05)    );
  // itree = 56
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.521142,0.00458889) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.681661,0.0160033) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.465898,-0.00528315) , 
1, 0.107733, 1, 0, 0.483714,-0.0169359) , 
14, 84.7295, 0, 0, 0.5,-1.64e-05)    );
  // itree = 57
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.517338,0.0015403) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.433616,-0.00560848) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.129032,-0.0414831) , 
7, 2.38813, 1, 0, 0.388221,-0.0477457) , 
11, 0.0421796, 0, 0, 0.5,-1.35998e-05)    );
  // itree = 58
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.518589,0.0021103) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.505308,-0.000564662) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.321154,-0.0194861) , 
3, 1.66347, 1, 0, 0.439808,-0.0328752) , 
13, 106.624, 0, 0, 0.5,-1.7728e-05)    );
  // itree = 59
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.681592,0.0148214) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.516188,0.00102174) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.320423,-0.0136291) , 
10, 0.495645, 0, 0, 0.487401,-0.00484071) , 
12, 0.200135, 0, 0, 0.5,-1.82034e-05)    );
  // itree = 60
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.510046,0.000951712) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.433962,-0.000860744) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.307116,-0.0212554) , 
9, 1.66445, 0, 0, 0.343164,-0.0712338) , 
14, 50.0041, 0, 0, 0.5,-1.73707e-05)    );
  // itree = 61
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.516414,0.00174766) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.625,0.00985556) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.400404,-0.0103056) , 
3, 0.760868, 1, 0, 0.424707,-0.0383493) , 
13, 149.273, 1, 0, 0.5,-1.71986e-05)    );
  // itree = 62
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.521142,0.00413084) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.564384,0.00302205) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.42598,-0.00779702) , 
10, 0.649346, 0, 0, 0.483714,-0.0151988) , 
14, 84.7295, 0, 0, 0.5,-1.60443e-05)    );
  // itree = 63
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.619048,0.00862456) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.636136,0.00877421) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.449583,-0.0034666) , 
10, 0.795652, 0, 0, 0.478011,-0.00758512) , 
12, 0.124827, 0, 0, 0.5,-1.49077e-05)    );
  // itree = 64
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.515032,0.00118081) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.52518,0.00582316) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.313433,-0.0169146) , 
12, 0.0678503, 0, 0, 0.361842,-0.052002) , 
13, 85.299, 0, 0, 0.5,-1.1897e-05)    );
  // itree = 65
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.506513,0.000670615) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.361702,0.0095828) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.298137,-0.0278889) , 
3, 2.2744, 0, 0, 0.3125,-0.092245) , 
13, 191.923, 1, 0, 0.5,-1.25676e-05)    );
  // itree = 66
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.550725,0.0121267) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.535431,0.0013228) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.400119,-0.00691757) , 
5, 1.69351, 1, 0, 0.495712,-0.00489955) , 
14, 136.817, 0, 0, 0.5,-1.27015e-05)    );
  // itree = 67
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.572407,0.00510095) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.529669,0.00170108) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.35871,-0.00967777) , 
3, 1.58426, 1, 0, 0.468001,-0.0107563) , 
12, 0.0495194, 0, 0, 0.5,-1.21125e-05)    );
  // itree = 68
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.510046,0.000845459) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.5375,0.0030422) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.290102,-0.0186882) , 
1, 0.164633, 1, 0, 0.343164,-0.0629429) , 
14, 50.0041, 0, 0, 0.5,-1.2383e-05)    );
  // itree = 69
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.516414,0.00155568) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.429283,-0.00907109) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.380952,0.0126918) , 
3, 2.42791, 1, 0, 0.424707,-0.033966) , 
13, 149.273, 1, 0, 0.5,-1.28777e-05)    );
  // itree = 70
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.518589,0.00188958) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.520384,0.000261319) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.332803,-0.0156631) , 
4, 1.79544, 1, 0, 0.439808,-0.029235) , 
13, 106.624, 0, 0, 0.5,-1.22415e-05)    );
  // itree = 71
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.702041,0.0164518) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.516071,0.00416224) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.477285,-0.00352773) , 
14, 89.2373, 0, 0, 0.491682,-0.00317006) , 
10, 0.86232, 0, 0, 0.5,-1.28391e-05)    );
  // itree = 72
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.517338,0.00128832) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.508021,0.00825191) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.353488,-0.013783) , 
0, 0.331717, 0, 0, 0.388221,-0.0396199) , 
11, 0.0421796, 0, 0, 0.5,-1.02962e-05)    );
  // itree = 73
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.506513,0.000597744) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.338462,0.00410661) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.300699,-0.0269208) , 
4, 2.60649, 0, 0, 0.3125,-0.0819036) , 
13, 191.923, 1, 0, 0.5,-1.06002e-05)    );
  // itree = 74
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.514756,0.000797472) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.268657,0.000953712) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.264957,-0.0221421) , 
5, 2.41155, 0, 0, 0.266304,-0.0604345) , 
4, 3.29351, 1, 0, 0.5,-1.06808e-05)    );
  // itree = 75
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.681592,0.0123674) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.501927,0.000202402) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.257971,-0.0192518) , 
10, 0.428977, 0, 0, 0.487401,-0.00397724) , 
12, 0.200135, 0, 0, 0.5,-1.1703e-05)    );
  // itree = 76
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.519206,0.00244195) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.522924,-0.000335592) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.375,-0.010651) , 
8, 259.178, 1, 0, 0.468974,-0.0187855) , 
13, 117.286, 0, 0, 0.5,-1.19515e-05)    );
  // itree = 77
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.550725,0.0107673) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.498236,-0.000634019) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.162791,-0.0429484) , 
5, 4.65708, 1, 0, 0.495712,-0.00432945) , 
14, 136.817, 0, 0, 0.5,-1.16547e-05)    );
  // itree = 78
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.516414,0.00146028) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.428571,-0.0175808) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.423651,-0.00367861) , 
0, 0.57028, 0, 0, 0.424707,-0.0317624) , 
13, 149.273, 1, 0, 0.5,-1.19336e-05)    );
  // itree = 79
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.515032,0.000986213) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.529412,0.0141394) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.340741,-0.0128328) , 
9, 0.648935, 1, 0, 0.361842,-0.0431935) , 
13, 85.299, 0, 0, 0.5,-1.06663e-05)    );
  // itree = 80
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.558103,0.00356484) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.550459,0.010498) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.447678,-0.00429155) , 
9, 0.776456, 1, 0, 0.459902,-0.0117709) , 
5, 0.846781, 1, 0, 0.5,-1.07305e-05)    );
  // itree = 81
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.510046,0.000751532) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.433962,0.00212192) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.307116,-0.0181642) , 
9, 1.66445, 0, 0, 0.343164,-0.0556662) , 
14, 50.0041, 0, 0, 0.5,-9.62454e-06)    );
  // itree = 82
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.572407,0.00441276) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.529669,0.00123314) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.35871,-0.00797352) , 
3, 1.58426, 1, 0, 0.468001,-0.00924753) , 
12, 0.0495194, 0, 0, 0.5,-9.93645e-06)    );
  // itree = 83
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.506963,0.000470406) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.363636,-0.00301649) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.163265,-0.0323268) , 
1, 0.421456, 1, 0, 0.243902,-0.0821725) , 
9, 2.54676, 1, 0, 0.5,-9.98197e-06)    );
  // itree = 84
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.521142,0.0032301) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.551607,0.00190314) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.414013,-0.00724965) , 
10, 0.617093, 0, 0, 0.483714,-0.01176) , 
14, 84.7295, 0, 0, 0.5,-1.15675e-05)    );
  // itree = 85
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.516414,0.00133451) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.429283,-0.00805059) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.380952,0.013989) , 
3, 2.42791, 1, 0, 0.424707,-0.0289327) , 
13, 149.273, 1, 0, 0.5,-1.09225e-05)    );
  // itree = 86
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.519206,0.00224882) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.472812,-0.00688858) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.462253,0.002055) , 
9, 1.45168, 1, 0, 0.468974,-0.0172396) , 
13, 117.286, 0, 0, 0.5,-1.05373e-05)    );
  // itree = 87
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.694656,0.0140017) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.505749,0.000323442) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.274457,-0.0164195) , 
10, 0.428977, 0, 0, 0.491405,-0.00284664) , 
12, 0.225238, 0, 0, 0.5,-9.36295e-06)    );
  // itree = 88
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.504113,0.000386256) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.442308,0.00256584) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.166667,-0.0409201) , 
14, 108.303, 0, 0, 0.288136,-0.09418) , 
13, 202.585, 1, 0, 0.5,-9.30582e-06)    );
  // itree = 89
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.702041,0.0139393) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.551724,0.0128674) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.488281,-0.0013265) , 
14, 145.833, 0, 0, 0.491682,-0.00264543) , 
10, 0.86232, 0, 0, 0.5,-1.06875e-05)    );
  // itree = 90
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.526063,0.00120176) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.365019,0.00169154) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.363057,-0.0151954) , 
2, 2.14793, 0, 0, 0.364092,-0.0297576) , 
8, 378.741, 1, 0, 0.5,-8.6567e-06)    );
  // itree = 91
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.51156,0.000708809) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.398734,-0.00434257) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.0833333,-0.045546) , 
6, 2.24827, 1, 0, 0.3325,-0.0486821) , 
13, 74.6367, 0, 0, 0.5,-8.7717e-06)    );
  // itree = 92
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.515888,0.00180308) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.631336,0.00858024) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.415655,-0.00784324) , 
1, 0.191276, 1, 0, 0.464509,-0.01902) , 
14, 67.3668, 0, 0, 0.5,-1.24665e-05)    );
  // itree = 93
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.516414,0.00123615) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.429283,-0.00746163) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.380952,0.0128705) , 
3, 2.42791, 1, 0, 0.424707,-0.0267319) , 
13, 149.273, 1, 0, 0.5,-1.12881e-05)    );
  // itree = 94
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.53563,0.0017593) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.741379,0.0229584) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.402823,-0.00569625) , 
12, 0.25034, 0, 0, 0.422881,-0.0181767) , 
0, 0.327257, 0, 0, 0.5,-1.07671e-05)    );
  // itree = 95
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.519206,0.00204132) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.48286,-0.00508265) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.382263,0.00867287) , 
6, 2.61518, 1, 0, 0.468974,-0.015595) , 
13, 117.286, 0, 0, 0.5,-8.92696e-06)    );
  // itree = 96
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.550725,0.00887773) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.522648,0.00317758) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.481102,-0.00289314) , 
14, 87.1773, 0, 0, 0.495712,-0.00354805) , 
14, 136.817, 0, 0, 0.5,-8.35428e-06)    );
  // itree = 97
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.546734,0.0028473) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.533518,0.00154419) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.339937,-0.00945324) , 
3, 1.58426, 1, 0, 0.46219,-0.0108878) , 
12, -0.000685741, 0, 0, 0.5,-7.39763e-06)    );
  // itree = 98
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.553265,0.0028481) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.447234,-0.00269847) , 
5, 1.10786, 1, 0, 0.50244,0.00104447) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.1875,-0.0334602) , 
5, 4.65708, 1, 0, 0.5,-8.21289e-06)    );
  // itree = 99
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.506513,0.000470352) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.347518,-0.00421219) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.238806,-0.0347609) , 
12, 0.00321025, 1, 0, 0.3125,-0.0638068) , 
13, 191.923, 1, 0, 0.5,-8.39455e-06)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
