// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.1.2         [262402]
ROOT Release   : 5.32/00       [335872]
Creator        : gsmith
Date           : Mon Jun 24 14:21:31 2013
Host           : Linux lxbuild167.cern.ch 2.6.18-308.1.1.el5 #1 SMP Wed Mar 7 19:25:07 CET 2012 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /home/gsmith/cms_work/CMSSW_5_2_6/src/AnalysisCode/LeptonPlusJets/macros/tmva
Training events: 762
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
BoostType: "Grad" [Boosting type for the trees in the forest]
UseBaggedGrad: "False" [Use only a random subsample of all events for growing the trees in each iteration. (Only valid for GradBoost)]
Shrinkage: "1.000000e-01" [Learning rate for GradBoost algorithm]
nCuts: "20" [Number of steps during node cut optimisation]
NNodesMax: "4" [Max number of nodes in tree]
NegWeightTreatment: "ignorenegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : Ignore;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!); Randomly pair events with negative and positive weights in leaf node and do not boost them (experimental!) ]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
RenormByClass: "False" [Individually re-normalize each event class to the original size after boosting]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2t (Linear,Quadratic or Exponential)]
GradBaggingFraction: "6.000000e-01" [Defines the fraction of events to be used in each iteration when UseBaggedGrad=kTRUE. (Only valid for GradBoost)]
AdaBoostBeta: "1.000000e+00" [Parameter for AdaBoost algorithm]
UseRandomisedTrees: "False" [Choose at each node splitting a random set of variables]
UseNvars: "3" [Number of variables used if randomised tree option is chosen]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split]
UseNTrainEvents: "762" [Number of randomly picked training events used in randomised (and bagged) trees]
UseWeightedTrees: "True" [Use weighted trees or simple average in classification from the forest]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
SeparationType: "giniindex" [Separation criterion for node splitting]
nEventsMin: "40" [Minimum number of events required in a leaf node (default: Classification: max(40, N_train/(Nvar^2)/10), Regression: 10)]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
PruneStrength: "0.000000e+00" [Pruning strength]
PruneMethod: "nopruning" [Method used for pruning (removal) of statistically insignificant branches]
PruneBeforeBoost: "False" [Flag to prune the tree before applying boosting algorithm]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
MaxDepth: "3" [Max depth of the decision tree allowed]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 10
avg_dr_tagged_jets            avg_dr_tagged_jets            avg_dr_tagged_jets            avg_dr_tagged_jets            avg_dr_tagged_jets                'F'    [0.918185055256,3.13105463982]
maxeta_tag_tag                maxeta_tag_tag                maxeta_tag_tag                maxeta_tag_tag                maxeta_tag_tag                    'F'    [0.15658955276,4.09609413147]
h1                            h1                            h1                            h1                            h1                                'F'    [-0.153674811125,0.322594851255]
h3                            h3                            h3                            h3                            h3                                'F'    [-0.00084980763495,0.878515660763]
all_sum_pt_with_met           all_sum_pt_with_met           all_sum_pt_with_met           all_sum_pt_with_met           all_sum_pt_with_met               'F'    [264.283111572,1439.42590332]
tagged_dijet_mass_closest_to_125 tagged_dijet_mass_closest_to_125 tagged_dijet_mass_closest_to_125 tagged_dijet_mass_closest_to_125 tagged_dijet_mass_closest_to_125     'F'    [0,212.051177979]
MET                           MET                           MET                           MET                           MET                               'F'    [2.04018974304,450.873413086]
aplanarity                    aplanarity                    aplanarity                    aplanarity                    aplanarity                        'F'    [0.00280607957393,0.427565217018]
pt_all_jets_over_E_all_jets   pt_all_jets_over_E_all_jets   pt_all_jets_over_E_all_jets   pt_all_jets_over_E_all_jets   pt_all_jets_over_E_all_jets       'F'    [0.290527492762,0.950735390186]
fourth_highest_btag           fourth_highest_btag           fourth_highest_btag           fourth_highest_btag           fourth_highest_btag               'F'    [0.679231524467,0.995511353016]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 10 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "avg_dr_tagged_jets", "maxeta_tag_tag", "h1", "h3", "all_sum_pt_with_met", "tagged_dijet_mass_closest_to_125", "MET", "aplanarity", "pt_all_jets_over_E_all_jets", "fourth_highest_btag" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0.91818505525589;
      fVmax[0] = 3.13105463981628;
      fVmin[1] = 0.156589552760124;
      fVmax[1] = 4.09609413146973;
      fVmin[2] = -0.153674811124802;
      fVmax[2] = 0.322594851255417;
      fVmin[3] = -0.000849807634949684;
      fVmax[3] = 0.878515660762787;
      fVmin[4] = 264.283111572266;
      fVmax[4] = 1439.42590332031;
      fVmin[5] = 0;
      fVmax[5] = 212.051177978516;
      fVmin[6] = 2.04018974304199;
      fVmax[6] = 450.873413085938;
      fVmin[7] = 0.00280607957392931;
      fVmax[7] = 0.427565217018127;
      fVmin[8] = 0.290527492761612;
      fVmax[8] = 0.95073539018631;
      fVmin[9] = 0.679231524467468;
      fVmax[9] = 0.9955113530159;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[10];
   double fVmax[10];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[10];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += current->GetResponse();
   }
   return 2.0/(1.0+exp(-2.0*myMVA))-1.0;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.59633,0.0192661) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.436441,-0.0127119) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.2,-0.06) , 
0, 2.49912, 1, 0, 0.371166,-0.128834) , 
0, 2.18268, 1, 0, 0.5,0)    );
  // itree = 1
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.59633,0.0173461) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.42471,-0.0133737) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.164179,-0.0613918) , 
0, 2.5894, 1, 0, 0.371166,-0.115961) , 
0, 2.18268, 1, 0, 0.5,-3.66858e-06)    );
  // itree = 2
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.552335,0.00868448) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.38983,-0.0158262) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.182927,-0.0549389) , 
8, 0.558751, 0, 0, 0.269504,-0.191106) , 
0, 2.39343, 1, 0, 0.5,-1.50054e-05)    );
  // itree = 3
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.59633,0.0147698) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.571429,0.0164692) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.32963,-0.0274678) , 
8, 0.746008, 0, 0, 0.371166,-0.0986367) , 
0, 2.18268, 1, 0, 0.5,-3.0799e-05)    );
  // itree = 4
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.540179,0.00568982) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.272727,-0.0305249) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.130435,-0.0566655) , 
8, 0.522604, 0, 0, 0.2,-0.212015) , 
0, 2.49881, 1, 0, 0.5,-3.49056e-05)    );
  // itree = 5
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.59633,0.0127549) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.575,0.0222847) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.342657,-0.022841) , 
6, 106.768, 0, 0, 0.371166,-0.0850542) , 
0, 2.18268, 1, 0, 0.5,-5.50136e-05)    );
  // itree = 6
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.621723,0.0183487) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.56044,0.0103175) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.361022,-0.0219536) , 
3, 0.228537, 1, 0, 0.434343,-0.0492975) , 
1, 1.28216, 1, 0, 0.5,-5.6237e-05)    );
  // itree = 7
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.540179,0.00463565) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.261905,-0.023713) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.145833,-0.0485097) , 
6, 43.3402, 0, 0, 0.2,-0.172351) , 
0, 2.49881, 1, 0, 0.5,-5.28897e-05)    );
  // itree = 8
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.642336,0.0264884) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.606061,0.0170674) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.432049,-0.012055) , 
7, 0.164619, 0, 0, 0.4688,-0.0287443) , 
4, 711.957, 0, 0, 0.5,-6.95219e-05)    );
  // itree = 9
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.545455,0.00796922) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.246154,-0.0466665) , 
5, 143.532, 1, 0, 0.518207,0.0150752) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.229167,-0.0466719) , 
5, 100.977, 0, 0, 0.5,-6.01235e-05)    );
  // itree = 10
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.624454,0.0175385) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.584746,0.0116175) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.3367,-0.0233561) , 
3, 0.208523, 1, 0, 0.446529,-0.0374324) , 
8, 0.762105, 0, 0, 0.5,-6.59115e-05)    );
  // itree = 11
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.642336,0.0239019) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.486207,-0.00232997) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.244444,-0.0438189) , 
4, 370.462, 0, 0, 0.4688,-0.025757) , 
4, 711.957, 0, 0, 0.5,-6.48764e-05)    );
  // itree = 12
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.539964,0.0066719) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.464567,-0.00666607) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.25,-0.0415473) , 
5, 142.826, 1, 0, 0.386935,-0.0927022) , 
5, 131.27, 1, 0, 0.5,-6.05701e-05)    );
  // itree = 13
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.560377,0.00919055) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.401099,-0.0156681) , 
5, 131.27, 1, 0, 0.519663,0.0141495) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.22,-0.0430424) , 
2, -0.108316, 0, 0, 0.5,-6.24126e-05)    );
  // itree = 14
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.545455,0.00661909) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.246154,-0.0371219) , 
5, 143.532, 1, 0, 0.518207,0.0135124) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.229167,-0.0426285) , 
5, 100.977, 0, 0, 0.5,-6.52485e-05)    );
  // itree = 15
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.642336,0.0223921) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.636364,0.0285355) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.452632,-0.00818548) , 
9, 0.935268, 0, 0, 0.4688,-0.023951) , 
4, 711.957, 0, 0, 0.5,-7.42214e-05)    );
  // itree = 16
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.621723,0.0139102) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.62963,0.0204135) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.396135,-0.0132595) , 
2, 0.141159, 0, 0, 0.434343,-0.0369413) , 
1, 1.28216, 1, 0, 0.5,-6.36528e-05)    );
  // itree = 17
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.554276,0.00715656) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.311321,-0.0251363) , 
5, 138.261, 1, 0, 0.518207,0.0122045) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.229167,-0.0391199) , 
5, 100.977, 0, 0, 0.5,-5.56361e-05)    );
  // itree = 18
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.624454,0.0143924) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.584746,0.00945151) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.3367,-0.019318) , 
3, 0.208523, 1, 0, 0.446529,-0.0303742) , 
8, 0.762105, 0, 0, 0.5,-6.24568e-05)    );
  // itree = 19
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.642336,0.0201223) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.501134,0.00194664) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.391304,-0.019664) , 
5, 116.993, 0, 0, 0.4688,-0.0212304) , 
4, 711.957, 0, 0, 0.5,-6.1147e-05)    );
  // itree = 20
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.529506,0.00424439) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.419355,-0.0087448) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.238095,-0.0452175) , 
9, 0.788252, 0, 0, 0.362963,-0.0953972) , 
4, 432.161, 0, 0, 0.5,-5.27122e-05)    );
  // itree = 21
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.551195,0.00673383) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.373016,-0.0178718) , 
4, 432.161, 0, 0, 0.519663,0.0116915) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.22,-0.0371013) , 
2, -0.108316, 0, 0, 0.5,-5.24937e-05)    );
  // itree = 22
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.66129,0.0292087) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.681818,0.027372) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.4653,-0.00576201) , 
6, 130.278, 0, 0, 0.485714,-0.0125914) , 
9, 0.935268, 0, 0, 0.5,-5.70136e-05)    );
  // itree = 23
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.539179,0.005658) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.681818,0.0267054) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.340659,-0.0240186) , 
2, 0.141159, 0, 0, 0.40708,-0.0650543) , 
7, 0.063486, 0, 0, 0.5,-4.63234e-05)    );
  // itree = 24
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.545455,0.00541033) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.246154,-0.0322646) , 
5, 143.532, 1, 0, 0.518207,0.0103792) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.229167,-0.0344878) , 
5, 100.977, 0, 0, 0.5,-4.45313e-05)    );
  // itree = 25
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.642336,0.0178527) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.606061,0.014012) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.432049,-0.0087887) , 
7, 0.164619, 0, 0, 0.4688,-0.0185883) , 
4, 711.957, 0, 0, 0.5,-5.47988e-05)    );
  // itree = 26
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.621723,0.0108732) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.56044,0.00700582) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.361022,-0.0139067) , 
3, 0.228537, 1, 0, 0.434343,-0.0284232) , 
1, 1.28216, 1, 0, 0.5,-4.57106e-05)    );
  // itree = 27
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.66129,0.0263779) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.582278,0.00730461) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.40625,-0.0106173) , 
8, 0.699228, 0, 0, 0.485714,-0.0112355) , 
9, 0.935268, 0, 0, 0.5,-4.29838e-05)    );
  // itree = 28
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.539964,0.00463336) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.441176,-0.00484602) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.269841,-0.0325838) , 
4, 486.47, 0, 0, 0.386935,-0.0627375) , 
5, 131.27, 1, 0, 0.5,-3.75156e-05)    );
  // itree = 29
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.545455,0.00480487) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.246154,-0.0288032) , 
5, 143.532, 1, 0, 0.518207,0.00932167) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.229167,-0.0316719) , 
5, 100.977, 0, 0, 0.5,-3.92493e-05)    );
  // itree = 30
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.536842,0.00419002) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.217391,-0.0325167) , 
2, -0.108316, 0, 0, 0.516174,0.00958584) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.27451,-0.029574) , 
4, 376.201, 0, 0, 0.5,-4.8646e-05)    );
  // itree = 31
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.680556,0.0232575) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.621359,0.0108409) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.421488,-0.00824452) , 
8, 0.762105, 0, 0, 0.481159,-0.0114966) , 
6, 130.278, 0, 0, 0.5,-5.47595e-05)    );
  // itree = 32
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.539179,0.00459984) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.690476,0.0256846) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.342391,-0.0202529) , 
3, 0.124774, 1, 0, 0.40708,-0.0521696) , 
7, 0.063486, 0, 0, 0.5,-4.49222e-05)    );
  // itree = 33
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.642336,0.0156912) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.501134,0.00222642) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.391304,-0.0169481) , 
5, 116.993, 0, 0, 0.4688,-0.0159703) , 
4, 711.957, 0, 0, 0.5,-4.2583e-05)    );
  // itree = 34
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.66129,0.0237946) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.529183,0.00266587) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.365591,-0.015767) , 
5, 131.27, 1, 0, 0.485714,-0.00999314) , 
9, 0.935268, 0, 0, 0.5,-3.68486e-05)    );
  // itree = 35
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.644269,0.0121897) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.445415,-0.0040324) , 
1, 1.28216, 1, 0, 0.516174,0.00844905) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.27451,-0.0265107) , 
4, 376.201, 0, 0, 0.5,-3.37055e-05)    );
  // itree = 36
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.554276,0.00501116) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.311321,-0.0186341) , 
5, 138.261, 1, 0, 0.518207,0.00799097) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.229167,-0.0281242) , 
5, 100.977, 0, 0, 0.5,-3.04362e-05)    );
  // itree = 37
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.642336,0.0143477) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.501134,0.002099) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.391304,-0.0156021) , 
5, 116.993, 0, 0, 0.4688,-0.0144285) , 
4, 711.957, 0, 0, 0.5,-3.63265e-05)    );
  // itree = 38
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.539179,0.00423921) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.681818,0.0232718) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.340659,-0.0192185) , 
2, 0.141159, 0, 0, 0.40708,-0.0476792) , 
7, 0.063486, 0, 0, 0.5,-3.15687e-05)    );
  // itree = 39
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.66129,0.0214574) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.681818,0.020881) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.4653,-0.00425902) , 
6, 130.278, 0, 0, 0.485714,-0.0088935) , 
9, 0.935268, 0, 0, 0.5,-3.065e-05)    );
  // itree = 40
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.672727,0.0150093) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.671053,0.0209121) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.444444,-0.00574902) , 
3, 0.0945666, 1, 0, 0.470859,-0.0118937) , 
1, 0.906971, 1, 0, 0.5,-2.25108e-05)    );
  // itree = 41
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.519939,0.00250314) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.559322,0.00250452) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.176471,-0.0398259) , 
0, 2.3141, 1, 0, 0.381818,-0.0694815) , 
7, 0.0432593, 0, 0, 0.5,-1.46653e-05)    );
  // itree = 42
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.642336,0.0132012) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.508121,0.00215687) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.381443,-0.014059) , 
4, 455.405, 0, 0, 0.4688,-0.013098) , 
4, 711.957, 0, 0, 0.5,-2.54569e-05)    );
  // itree = 43
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.539964,0.00357991) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.508772,0.00746584) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.338028,-0.0177792) , 
4, 645.296, 0, 0, 0.386935,-0.047301) , 
5, 131.27, 1, 0, 0.5,-2.25519e-05)    );
  // itree = 44
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.512012,0.00225118) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.518519,0.00169667) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.285714,-0.0384164) , 
7, 0.0853214, 0, 0, 0.416667,-0.0723871) , 
9, 0.724414, 0, 0, 0.5,-2.36553e-05)    );
  // itree = 45
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.524625,0.00468803) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.54,0.00777988) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.420513,-0.0152052) , 
9, 0.870676, 0, 0, 0.461017,-0.0343744) , 
5, 121.172, 0, 0, 0.5,-2.36008e-05)    );
  // itree = 46
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.539964,0.0033869) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.518072,0.00284866) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.293103,-0.0199957) , 
8, 0.688906, 0, 0, 0.386935,-0.0446839) , 
5, 131.27, 1, 0, 0.5,-2.11964e-05)    );
  // itree = 47
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.545455,0.00376966) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.246154,-0.0238668) , 
5, 143.532, 1, 0, 0.518207,0.00692245) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.229167,-0.0252219) , 
5, 100.977, 0, 0, 0.5,-2.41944e-05)    );
  // itree = 48
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.689655,0.0239916) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.500766,-0.000449513) , 
9, 0.935268, 0, 0, 0.516174,0.00703248) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.27451,-0.0227871) , 
4, 376.201, 0, 0, 0.5,-3.15647e-05)    );
  // itree = 49
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.519939,0.00228487) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.559322,0.00170054) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.176471,-0.0365818) , 
0, 2.3141, 1, 0, 0.381818,-0.0630182) , 
7, 0.0432593, 0, 0, 0.5,-2.83766e-05)    );
  // itree = 50
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.642336,0.0122841) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.501134,0.0020569) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.391304,-0.0138993) , 
5, 116.993, 0, 0, 0.4688,-0.0120365) , 
4, 711.957, 0, 0, 0.5,-3.64886e-05)    );
  // itree = 51
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.525843,0.00453719) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.682927,0.0201934) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.431159,-0.0104894) , 
3, 0.0993781, 1, 0, 0.463722,-0.0293202) , 
9, 0.81478, 0, 0, 0.5,-3.21195e-05)    );
  // itree = 52
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.573276,0.00607197) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.419355,-0.00771664) , 
8, 0.604912, 0, 0, 0.519663,0.0064589) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.22,-0.0233249) , 
2, -0.108316, 0, 0, 0.5,-2.73691e-05)    );
  // itree = 53
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.539964,0.00306271) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.508772,0.0075056) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.338028,-0.0157739) , 
4, 645.296, 0, 0, 0.386935,-0.0400873) , 
5, 131.27, 1, 0, 0.5,-2.87408e-05)    );
  // itree = 54
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.524625,0.00420471) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.54,0.00652251) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.420513,-0.013386) , 
9, 0.870676, 0, 0, 0.461017,-0.0304761) , 
5, 121.172, 0, 0, 0.5,-2.87185e-05)    );
  // itree = 55
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.640909,0.00990087) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.460285,-0.00255824) , 
8, 0.762105, 0, 0, 0.516174,0.00620295) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.27451,-0.020457) , 
4, 376.201, 0, 0, 0.5,-2.60128e-05)    );
  // itree = 56
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.613793,0.0100425) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.486772,-0.000305071) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.32,-0.0271853) , 
9, 0.709353, 0, 0, 0.473258,-0.0110878) , 
7, 0.164619, 0, 0, 0.5,-2.37651e-05)    );
  // itree = 57
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.539964,0.00293423) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.489362,0.00836924) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.355263,-0.0141046) , 
9, 0.890085, 0, 0, 0.386935,-0.0382396) , 
5, 131.27, 1, 0, 0.5,-2.21398e-05)    );
  // itree = 58
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.524625,0.00397789) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.464567,-0.00965677) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.439024,0.0177488) , 
3, 0.545908, 1, 0, 0.461017,-0.0286925) , 
5, 121.172, 0, 0, 0.5,-2.21173e-05)    );
  // itree = 59
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.519939,0.00198819) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.468085,0.0067027) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.31746,-0.0272069) , 
7, 0.0277998, 1, 0, 0.381818,-0.054352) , 
7, 0.0432593, 0, 0, 0.5,-2.0653e-05)    );
  // itree = 60
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.680556,0.0156597) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.5,-0.0187635) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.479167,0.000265871) , 
0, 1.86656, 1, 0, 0.481159,-0.0073025) , 
6, 130.278, 0, 0, 0.5,-2.12124e-05)    );
  // itree = 61
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.545455,0.0032948) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.246154,-0.0217846) , 
5, 143.532, 1, 0, 0.518207,0.00573015) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.229167,-0.0216043) , 
5, 100.977, 0, 0, 0.5,-1.45825e-05)    );
  // itree = 62
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.642336,0.0109578) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.616071,0.0117008) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.436647,-0.00549716) , 
3, 0.130149, 1, 0, 0.4688,-0.0105459) , 
4, 711.957, 0, 0, 0.5,-2.11153e-05)    );
  // itree = 63
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.529506,0.0021937) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.370787,0.00297459) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.347826,-0.0330714) , 
0, 2.11596, 0, 0, 0.362963,-0.0465283) , 
4, 432.161, 0, 0, 0.5,-1.65627e-05)    );
  // itree = 64
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.66129,0.0160792) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.647887,0.0168649) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.467409,-0.00357788) , 
2, 0.163838, 0, 0, 0.485714,-0.00642593) , 
9, 0.935268, 0, 0, 0.5,-1.47298e-05)    );
  // itree = 65
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.672727,0.0116385) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.671053,0.0169637) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.444444,-0.00454268) , 
3, 0.0945666, 1, 0, 0.470859,-0.00894774) , 
1, 0.906971, 1, 0, 0.5,-1.00305e-05)    );
  // itree = 66
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.519939,0.00190625) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.559322,0.00211273) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.176471,-0.0328196) , 
0, 2.3141, 1, 0, 0.381818,-0.0516961) , 
7, 0.0432593, 0, 0, 0.5,-4.90977e-06)    );
  // itree = 67
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.613793,0.00920715) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.486772,-0.000320155) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.32,-0.0246248) , 
9, 0.709353, 0, 0, 0.473258,-0.0100736) , 
7, 0.164619, 0, 0, 0.5,-1.35492e-05)    );
  // itree = 68
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.642336,0.0101531) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.508121,0.00188669) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.381443,-0.0112435) , 
4, 455.405, 0, 0, 0.4688,-0.00966985) , 
4, 711.957, 0, 0, 0.5,-1.30363e-05)    );
  // itree = 69
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.539964,0.00269374) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.401316,-0.0130708) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.340426,0.0120129) , 
1, 2.40774, 1, 0, 0.386935,-0.0347153) , 
5, 131.27, 1, 0, 0.5,-1.16614e-05)    );
  // itree = 70
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.524625,0.00365005) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.464567,-0.00901445) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.439024,0.0175491) , 
3, 0.545908, 1, 0, 0.461017,-0.0260136) , 
5, 121.172, 0, 0, 0.5,-1.23972e-05)    );
  // itree = 71
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.573276,0.00499734) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.419355,-0.00629319) , 
8, 0.604912, 0, 0, 0.519663,0.00538456) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.22,-0.020073) , 
2, -0.108316, 0, 0, 0.5,-1.19272e-05)    );
  // itree = 72
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.522822,0.00343129) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.565714,0.00226914) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.285714,-0.0211493) , 
1, 1.73556, 1, 0, 0.460714,-0.0267085) , 
9, 0.799719, 0, 0, 0.5,-1.39027e-05)    );
  // itree = 73
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.545455,0.00296135) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.246154,-0.020016) , 
5, 143.532, 1, 0, 0.518207,0.00500168) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.229167,-0.0194208) , 
5, 100.977, 0, 0, 0.5,-1.73353e-05)    );
  // itree = 74
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.666667,0.01423) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.518519,0.00105363) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.325397,-0.013047) , 
5, 134.993, 1, 0, 0.483405,-0.00611112) , 
4, 823.875, 0, 0, 0.5,-2.23185e-05)    );
  // itree = 75
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.524625,0.00339759) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.48583,-0.00167121) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.333333,-0.0241719) , 
6, 29.4674, 0, 0, 0.461017,-0.024066) , 
5, 121.172, 0, 0, 0.5,-2.07395e-05)    );
  // itree = 76
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.519939,0.00169701) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.468085,0.00712681) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.31746,-0.0246944) , 
7, 0.0277998, 1, 0, 0.381818,-0.0457293) , 
7, 0.0432593, 0, 0, 0.5,-1.98647e-05)    );
  // itree = 77
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.66129,0.0141819) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.647887,0.0158512) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.467409,-0.00327655) , 
2, 0.163838, 0, 0, 0.485714,-0.00558241) , 
9, 0.935268, 0, 0, 0.5,-2.02744e-05)    );
  // itree = 78
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.525843,0.00340135) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.521368,-0.0153074) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.43,0.00164536) , 
0, 2.07474, 1, 0, 0.463722,-0.0214457) , 
9, 0.81478, 0, 0, 0.5,-1.53938e-05)    );
  // itree = 79
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.642336,0.00915574) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.483333,-0.0183094) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.467257,-7.4251e-05) , 
0, 1.86656, 1, 0, 0.4688,-0.00859752) , 
4, 711.957, 0, 0, 0.5,-1.10024e-05)    );
  // itree = 80
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.672727,0.0100229) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.671053,0.0156672) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.444444,-0.00404432) , 
3, 0.0945666, 1, 0, 0.470859,-0.00758668) , 
1, 0.906971, 1, 0, 0.5,-7.02321e-06)    );
  // itree = 81
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.539179,0.00256468) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.582278,0.0119465) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.312925,-0.0173052) , 
2, 0.0731203, 0, 0, 0.40708,-0.0278319) , 
7, 0.063486, 0, 0, 0.5,-2.88206e-06)    );
  // itree = 82
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.554276,0.00320316) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.311321,-0.0128069) , 
5, 138.261, 1, 0, 0.518207,0.00459375) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.229167,-0.018116) , 
5, 100.977, 0, 0, 0.5,-6.02705e-06)    );
  // itree = 83
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.640909,0.00827821) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.460285,-0.0022745) , 
8, 0.762105, 0, 0, 0.516174,0.00470074) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.27451,-0.0160796) , 
4, 376.201, 0, 0, 0.5,-9.72182e-06)    );
  // itree = 84
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.524625,0.00310755) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.464567,-0.00814452) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.439024,0.0186469) , 
3, 0.545908, 1, 0, 0.461017,-0.0218205) , 
5, 121.172, 0, 0, 0.5,-8.85766e-06)    );
  // itree = 85
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.680556,0.0124106) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.5,-0.0170827) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.479167,0.000497869) , 
0, 1.86656, 1, 0, 0.481159,-0.00555313) , 
6, 130.278, 0, 0, 0.5,-8.93499e-06)    );
  // itree = 86
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.539964,0.00227114) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.401316,-0.0117946) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.340426,0.0132739) , 
1, 2.40774, 1, 0, 0.386935,-0.0288653) , 
5, 131.27, 1, 0, 0.5,-4.89303e-06)    );
  // itree = 87
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.519939,0.0015535) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.4,0.0102153) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.371429,-0.0207821) , 
6, 47.1335, 1, 0, 0.381818,-0.0415256) , 
7, 0.0432593, 0, 0, 0.5,-6.49038e-06)    );
  // itree = 88
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.56875,0.0045311) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.48374,0.00552145) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.408163,-0.0143577) , 
6, 41.7271, 1, 0, 0.450226,-0.0146658) , 
6, 66.1592, 0, 0, 0.5,-7.11396e-06)    );
  // itree = 89
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.666667,0.0128075) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.518519,0.000895756) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.325397,-0.0114099) , 
5, 134.993, 1, 0, 0.483405,-0.00537654) , 
4, 823.875, 0, 0, 0.5,-6.9275e-06)    );
  // itree = 90
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.512012,0.00145551) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.518519,0.00403353) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.285714,-0.0295772) , 
7, 0.0853214, 0, 0, 0.416667,-0.0448769) , 
9, 0.724414, 0, 0, 0.5,-6.70277e-06)    );
  // itree = 91
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.524625,0.00302246) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.464567,-0.00774937) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.439024,0.01684) , 
3, 0.545908, 1, 0, 0.461017,-0.0211491) , 
5, 121.172, 0, 0, 0.5,-8.50981e-06)    );
  // itree = 92
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.538462,0.00991012) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.513812,-0.0017915) , 
2, -0.0672064, 1, 0, 0.519663,0.00438813) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.22,-0.0169163) , 
2, -0.108316, 0, 0, 0.5,-8.39781e-06)    );
  // itree = 93
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.529506,0.00173555) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.370787,0.0042594) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.347826,-0.0290329) , 
0, 2.11596, 0, 0, 0.362963,-0.0359482) , 
4, 432.161, 0, 0, 0.5,-9.88787e-06)    );
  // itree = 94
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.613793,0.0074042) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.473477,0.00084144) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.472222,-0.0135533) , 
7, 0.126033, 1, 0, 0.473258,-0.00796825) , 
7, 0.164619, 0, 0, 0.5,-9.81705e-06)    );
  // itree = 95
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.66129,0.012599) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.647887,0.0148136) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.467409,-0.00298336) , 
2, 0.163838, 0, 0, 0.485714,-0.0048615) , 
9, 0.935268, 0, 0, 0.5,-7.33706e-06)    );
  // itree = 96
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.672727,0.00909988) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.671053,0.0144678) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.444444,-0.00368767) , 
3, 0.0945666, 1, 0, 0.470859,-0.00678793) , 
1, 0.906971, 1, 0, 0.5,-4.12267e-06)    );
  // itree = 97
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.519939,0.00145546) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.559322,0.00344287) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.176471,-0.0291069) , 
0, 2.3141, 1, 0, 0.381818,-0.0386664) , 
7, 0.0432593, 0, 0, 0.5,-7.49272e-07)    );
  // itree = 98
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.642336,0.00821129) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.508121,0.00187089) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.381443,-0.00977338) , 
4, 455.405, 0, 0, 0.4688,-0.00752786) , 
4, 711.957, 0, 0, 0.5,-7.8822e-06)    );
  // itree = 99
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.522822,0.00275566) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.565714,0.00236668) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.285714,-0.018243) , 
1, 1.73556, 1, 0, 0.460714,-0.0210204) , 
9, 0.799719, 0, 0, 0.5,-7.21014e-06)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
