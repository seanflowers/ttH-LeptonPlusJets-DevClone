// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.1.2         [262402]
ROOT Release   : 5.32/00       [335872]
Creator        : gsmith
Date           : Sun Jun 23 14:15:07 2013
Host           : Linux lxbuild167.cern.ch 2.6.18-308.1.1.el5 #1 SMP Wed Mar 7 19:25:07 CET 2012 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /home/gsmith/cms_work/CMSSW_5_2_6/src/AnalysisCode/LeptonPlusJets/macros/tmva
Training events: 9692
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "100" [Number of trees in the forest]
BoostType: "Grad" [Boosting type for the trees in the forest]
UseBaggedGrad: "False" [Use only a random subsample of all events for growing the trees in each iteration. (Only valid for GradBoost)]
Shrinkage: "1.000000e-01" [Learning rate for GradBoost algorithm]
nCuts: "20" [Number of steps during node cut optimisation]
NNodesMax: "5" [Max number of nodes in tree]
NegWeightTreatment: "ignorenegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : Ignore;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!); Randomly pair events with negative and positive weights in leaf node and do not boost them (experimental!) ]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
RenormByClass: "False" [Individually re-normalize each event class to the original size after boosting]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2t (Linear,Quadratic or Exponential)]
GradBaggingFraction: "6.000000e-01" [Defines the fraction of events to be used in each iteration when UseBaggedGrad=kTRUE. (Only valid for GradBoost)]
AdaBoostBeta: "1.000000e+00" [Parameter for AdaBoost algorithm]
UseRandomisedTrees: "False" [Choose at each node splitting a random set of variables]
UseNvars: "3" [Number of variables used if randomised tree option is chosen]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split]
UseNTrainEvents: "9692" [Number of randomly picked training events used in randomised (and bagged) trees]
UseWeightedTrees: "True" [Use weighted trees or simple average in classification from the forest]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
SeparationType: "giniindex" [Separation criterion for node splitting]
nEventsMin: "40" [Minimum number of events required in a leaf node (default: Classification: max(40, N_train/(Nvar^2)/10), Regression: 10)]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
PruneStrength: "0.000000e+00" [Pruning strength]
PruneMethod: "nopruning" [Method used for pruning (removal) of statistically insignificant branches]
PruneBeforeBoost: "False" [Flag to prune the tree before applying boosting algorithm]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
MaxDepth: "3" [Max depth of the decision tree allowed]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 10
h0                            h0                            h0                            h0                            h0                                'F'    [0.198397666216,0.436662733555]
all_sum_pt_with_met           all_sum_pt_with_met           all_sum_pt_with_met           all_sum_pt_with_met           all_sum_pt_with_met               'F'    [301.096862793,2186.82250977]
sphericity                    sphericity                    sphericity                    sphericity                    sphericity                        'F'    [0.0214823912829,0.933876872063]
avg_btag_disc_btags           avg_btag_disc_btags           avg_btag_disc_btags           avg_btag_disc_btags           avg_btag_disc_btags               'F'    [0.708269953728,0.99999153614]
second_highest_btag           second_highest_btag           second_highest_btag           second_highest_btag           second_highest_btag               'F'    [0.683702290058,0.999999880791]
third_highest_btag            third_highest_btag            third_highest_btag            third_highest_btag            third_highest_btag                'F'    [0.679063618183,0.999985694885]
fourth_highest_btag           fourth_highest_btag           fourth_highest_btag           fourth_highest_btag           fourth_highest_btag               'F'    [-1,0.678716719151]
maxeta_jet_jet                maxeta_jet_jet                maxeta_jet_jet                maxeta_jet_jet                maxeta_jet_jet                    'F'    [0.344052791595,4.38394451141]
pt_all_jets_over_E_all_jets   pt_all_jets_over_E_all_jets   pt_all_jets_over_E_all_jets   pt_all_jets_over_E_all_jets   pt_all_jets_over_E_all_jets       'F'    [0.218563511968,0.970315158367]
ttbb_tth_MVA_output_6j3t      ttbb_tth_MVA_output_6j3t      ttbb_tth_MVA_output_6j3t      ttbb_tth_MVA_output_6j3t      ttbb_tth_MVA_output_6j3t          'F'    [-0.839958131313,0.494376987219]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 10 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "h0", "all_sum_pt_with_met", "sphericity", "avg_btag_disc_btags", "second_highest_btag", "third_highest_btag", "fourth_highest_btag", "maxeta_jet_jet", "pt_all_jets_over_E_all_jets", "ttbb_tth_MVA_output_6j3t" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0.198397666215897;
      fVmax[0] = 0.43666273355484;
      fVmin[1] = 301.096862792969;
      fVmax[1] = 2186.82250976562;
      fVmin[2] = 0.0214823912829161;
      fVmax[2] = 0.933876872062683;
      fVmin[3] = 0.708269953727722;
      fVmax[3] = 0.999991536140442;
      fVmin[4] = 0.683702290058136;
      fVmax[4] = 0.99999988079071;
      fVmin[5] = 0.679063618183136;
      fVmax[5] = 0.999985694885254;
      fVmin[6] = -1;
      fVmax[6] = 0.678716719150543;
      fVmin[7] = 0.344052791595459;
      fVmax[7] = 4.38394451141357;
      fVmin[8] = 0.218563511967659;
      fVmax[8] = 0.970315158367157;
      fVmin[9] = -0.839958131313324;
      fVmax[9] = 0.494376987218857;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[10];
   double fVmax[10];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[10];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += current->GetResponse();
   }
   return 2.0/(1.0+exp(-2.0*myMVA))-1.0;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.602196,0.0204391) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.399652,-0.0200697) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.224377,-0.0551247) , 
9, -0.328622, 0, 0, 0.351632,-0.148368) , 
9, -0.0139412, 0, 0, 0.5,0)    );
  // itree = 1
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.602196,0.0184032) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.503836,0.00364165) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.314097,-0.0342307) , 
5, 0.908156, 0, 0, 0.351632,-0.13354) , 
9, -0.0139412, 0, 0, 0.5,-2.67266e-06)    );
  // itree = 2
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.617934,0.0197343) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.51237,0.00454851) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.330872,-0.0292547) , 
3, 0.944348, 0, 0, 0.378509,-0.10151) , 
9, 0.0495986, 0, 0, 0.5,-7.66032e-06)    );
  // itree = 3
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.602196,0.0151833) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.406677,-0.0120767) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.241458,-0.0423759) , 
9, -0.289289, 0, 0, 0.351632,-0.10991) , 
9, -0.0139412, 0, 0, 0.5,-1.11683e-05)    );
  // itree = 4
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.636976,0.0201418) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.5657,0.0140038) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.361259,-0.0216562) , 
5, 0.908135, 0, 0, 0.403413,-0.0706642) , 
9, 0.113138, 0, 0, 0.5,-2.0908e-05)    );
  // itree = 5
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.591357,0.0164264) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.464333,-0.0093352) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.23357,-0.0387219) , 
9, -0.20456, 0, 0, 0.411574,-0.0788611) , 
5, 0.847166, 0, 0, 0.5,-1.96903e-05)    );
  // itree = 6
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.584158,0.0106166) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.37601,-0.0142179) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.212087,-0.0415613) , 
9, -0.367973, 0, 0, 0.331475,-0.105525) , 
9, -0.0774809, 0, 0, 0.5,-2.9902e-05)    );
  // itree = 7
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.642375,0.0230753) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.575601,0.00490349) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.355055,-0.0189673) , 
9, 0.113138, 0, 0, 0.441779,-0.0467539) , 
3, 0.944426, 0, 0, 0.5,-4.11415e-05)    );
  // itree = 8
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.591357,0.0138091) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.570681,0.0190953) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.390625,-0.0177639) , 
6, 0.518755, 0, 0, 0.411574,-0.065924) , 
5, 0.847166, 0, 0, 0.5,-4.00239e-05)    );
  // itree = 9
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.636976,0.0156524) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.444016,-0.00579371) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.21619,-0.0367941) , 
9, -0.340742, 0, 0, 0.403413,-0.0543962) , 
9, 0.113138, 0, 0, 0.5,-3.73633e-05)    );
  // itree = 10
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.69226,0.0286168) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.52458,0.00685877) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.416455,-0.0147754) , 
6, 0.279022, 0, 0, 0.461186,-0.0284075) , 
5, 0.923576, 0, 0, 0.5,-4.30588e-05)    );
  // itree = 11
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.584868,0.0116313) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.448353,-0.00491718) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.332696,-0.0275478) , 
1, 568.009, 0, 0, 0.40971,-0.0605869) , 
3, 0.916642, 0, 0, 0.5,-3.25955e-05)    );
  // itree = 12
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.584158,0.00834011) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.391885,-0.00913204) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.239657,-0.0299756) , 
9, -0.29536, 0, 0, 0.331475,-0.0821295) , 
9, -0.0774809, 0, 0, 0.5,-3.17475e-05)    );
  // itree = 13
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.722509,0.0305786) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.556048,0.0116452) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.434193,-0.0106737) , 
6, 0.358961, 0, 0, 0.469629,-0.0202695) , 
5, 0.938858, 0, 0, 0.5,-4.11366e-05)    );
  // itree = 14
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.636976,0.0132061) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.443511,-0.00212309) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.329152,-0.0230457) , 
1, 570.486, 0, 0, 0.403413,-0.0454498) , 
9, 0.113138, 0, 0, 0.5,-2.9372e-05)    );
  // itree = 15
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.564369,0.0080896) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.447463,-0.00412017) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.330178,-0.0245832) , 
1, 632.677, 0, 0, 0.393024,-0.0651911) , 
3, 0.902751, 0, 0, 0.5,-2.76712e-05)    );
  // itree = 16
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.602196,0.00825635) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.399652,-0.00662296) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.224377,-0.0286207) , 
9, -0.328622, 0, 0, 0.351632,-0.0585385) , 
9, -0.0139412, 0, 0, 0.5,-2.91528e-05)    );
  // itree = 17
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.680723,0.0208636) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.49894,0.00182235) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.378873,-0.0178779) , 
1, 570.486, 0, 0, 0.458047,-0.023254) , 
3, 0.958317, 0, 0, 0.5,-3.67101e-05)    );
  // itree = 18
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.678451,0.0195945) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.568182,0.0141564) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.432659,-0.00915715) , 
6, 0.438821, 0, 0, 0.459798,-0.02136) , 
9, 0.240218, 0, 0, 0.5,-2.9474e-05)    );
  // itree = 19
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.642056,0.0146377) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.500305,0.00325666) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.392044,-0.0141285) , 
1, 660.283, 0, 0, 0.443354,-0.0279555) , 
5, 0.893012, 0, 0, 0.5,-2.17258e-05)    );
  // itree = 20
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.544524,0.00375618) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.314,-0.0109676) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.222787,-0.0285151) , 
1, 715.758, 0, 0, 0.25354,-0.100598) , 
9, -0.2681, 0, 0, 0.5,-1.80808e-05)    );
  // itree = 21
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.591357,0.00874275) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.570681,0.0168965) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.390625,-0.0119154) , 
6, 0.518755, 0, 0, 0.411574,-0.0405222) , 
5, 0.847166, 0, 0, 0.5,-2.75215e-05)    );
  // itree = 22
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.636976,0.0100182) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.510204,0.00871579) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.377002,-0.0111952) , 
6, 0.438821, 0, 0, 0.403413,-0.0339304) , 
9, 0.113138, 0, 0, 0.5,-2.60053e-05)    );
  // itree = 23
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.722509,0.0229403) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.534752,0.00700267) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.423746,-0.0102003) , 
6, 0.279022, 0, 0, 0.469629,-0.0145954) , 
5, 0.938858, 0, 0, 0.5,-2.38086e-05)    );
  // itree = 24
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.678451,0.0164409) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.544786,0.00777719) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.424719,-0.00851928) , 
6, 0.358886, 0, 0, 0.459798,-0.0176151) , 
9, 0.240218, 0, 0, 0.5,-1.57725e-05)    );
  // itree = 25
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.564369,0.00603853) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.556402,0.00605824) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.357119,-0.013883) , 
8, 0.751394, 0, 0, 0.393024,-0.0476317) , 
3, 0.902751, 0, 0, 0.5,-1.05642e-05)    );
  // itree = 26
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.544524,0.00319766) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.314,-0.00868133) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.222787,-0.0252222) , 
1, 715.758, 0, 0, 0.25354,-0.0847718) , 
9, -0.2681, 0, 0, 0.5,-1.26691e-05)    );
  // itree = 27
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.722509,0.0203019) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.508828,0.00270455) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.394385,-0.0132418) , 
1, 570.486, 0, 0, 0.469629,-0.0127004) , 
5, 0.938858, 0, 0, 0.5,-2.06517e-05)    );
  // itree = 28
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.650105,0.0141475) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.511425,0.00108795) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.345543,-0.0149724) , 
3, 0.88886, 0, 0, 0.463111,-0.0165063) , 
8, 0.755529, 0, 0, 0.5,-1.4651e-05)    );
  // itree = 29
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.636132,0.0182761) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.504765,0.000653341) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.358751,-0.0195327) , 
1, 494.383, 0, 0, 0.481146,-0.0119486) , 
6, 0.518839, 0, 0, 0.5,-1.3879e-05)    );
  // itree = 30
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.584158,0.00465778) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.367258,-0.00604803) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.200577,-0.0255922) , 
9, -0.40428, 0, 0, 0.331475,-0.0445596) , 
9, -0.0774809, 0, 0, 0.5,-1.28164e-05)    );
  // itree = 31
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.559842,0.00765674) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.716279,0.0168444) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.423746,-0.0082944) , 
5, 0.938884, 0, 0, 0.457153,-0.0257267) , 
6, 0.279022, 0, 0, 0.5,-1.87729e-05)    );
  // itree = 32
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.678451,0.0136203) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.505223,0.000956372) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.339335,-0.0142484) , 
8, 0.52958, 0, 0, 0.459798,-0.0143399) , 
9, 0.240218, 0, 0, 0.5,-1.49817e-05)    );
  // itree = 33
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.546655,0.00394954) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.467448,0.00160763) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.346782,-0.0150417) , 
1, 790.9, 0, 0, 0.380778,-0.0472146) , 
3, 0.88886, 0, 0, 0.5,-1.34807e-05)    );
  // itree = 34
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.549789,0.00652757) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.507651,0.00114757) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.386311,-0.0154789) , 
1, 523.444, 0, 0, 0.456685,-0.0266475) , 
1, 660.283, 0, 0, 0.5,-1.49464e-05)    );
  // itree = 35
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.856354,0.0457455) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.633218,0.0156369) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.473848,-0.00312152) , 
6, 0.518839, 0, 0, 0.493218,-0.00388197) , 
5, 0.984704, 0, 0, 0.5,-1.4825e-05)    );
  // itree = 36
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.544524,0.0024378) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.272482,-0.0110041) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.196765,-0.0282789) , 
2, 0.18007, 0, 0, 0.25354,-0.0638231) , 
9, -0.2681, 0, 0, 0.5,-6.44101e-06)    );
  // itree = 37
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.546525,0.0037029) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.458333,-0.000746076) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.332714,-0.0157238) , 
1, 688.613, 0, 0, 0.386283,-0.0421369) , 
5, 0.786038, 0, 0, 0.5,-1.21093e-05)    );
  // itree = 38
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.678451,0.0120278) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.495123,0.00220743) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.404723,-0.0104053) , 
6, 0.199017, 0, 0, 0.459798,-0.0125237) , 
9, 0.240218, 0, 0, 0.5,-1.37533e-05)    );
  // itree = 39
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.680723,0.0119271) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.49894,0.00135806) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.378873,-0.0107935) , 
1, 570.486, 0, 0, 0.458047,-0.0125089) , 
3, 0.958317, 0, 0, 0.5,-1.07349e-05)    );
  // itree = 40
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.650105,0.0111121) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.55831,0.00455012) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.407649,-0.00703629) , 
4, 0.954814, 0, 0, 0.463111,-0.0126936) , 
8, 0.755529, 0, 0, 0.5,-8.48444e-06)    );
  // itree = 41
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.512783,0.00232733) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.483436,-0.00479397) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.361991,-0.0229683) , 
1, 627.529, 0, 0, 0.428958,-0.0595324) , 
6, 0.119144, 0, 0, 0.5,-6.44357e-06)    );
  // itree = 42
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.511365,0.00143999) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.398773,-0.0128481) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.211957,-0.0384044) , 
2, 0.104629, 0, 0, 0.347697,-0.0890032) , 
0, 0.345895, 0, 0, 0.5,-6.65282e-06)    );
  // itree = 43
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.559842,0.00611238) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.716279,0.0128798) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.423746,-0.00651931) , 
5, 0.938884, 0, 0, 0.457153,-0.0202257) , 
6, 0.279022, 0, 0, 0.5,-8.97963e-06)    );
  // itree = 44
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.856354,0.0401043) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.633218,0.013046) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.473848,-0.00259917) , 
6, 0.518839, 0, 0, 0.493218,-0.00321618) , 
5, 0.984704, 0, 0, 0.5,-6.86689e-06)    );
  // itree = 45
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.617934,0.00490261) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.38748,-0.00377476) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.252366,-0.0265509) , 
7, 3.09242, 1, 0, 0.378509,-0.0235898) , 
9, 0.0495986, 0, 0, 0.5,-2.38803e-07)    );
  // itree = 46
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.549789,0.00531847) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.507651,0.00123591) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.386311,-0.0130925) , 
1, 523.444, 0, 0, 0.456685,-0.0214038) , 
1, 660.283, 0, 0, 0.5,-2.11155e-06)    );
  // itree = 47
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.546655,0.00304634) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.566667,0.0313047) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.376594,-0.00881838) , 
4, 0.957483, 0, 0, 0.380778,-0.0358235) , 
3, 0.88886, 0, 0, 0.5,-3.12962e-06)    );
  // itree = 48
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.544485,0.0030855) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.683168,0.0149324) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.358491,-0.0105763) , 
9, 0.303758, 0, 0, 0.393045,-0.0343551) , 
8, 0.540743, 0, 0, 0.5,-4.29055e-06)    );
  // itree = 49
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.512783,0.00203435) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.496753,-0.00204007) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.38051,-0.0179563) , 
1, 701.201, 0, 0, 0.428958,-0.0516136) , 
6, 0.119144, 0, 0, 0.5,-5.09885e-06)    );
  // itree = 50
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.511365,0.00126594) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.385172,-0.0127657) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.175,-0.0398627) , 
3, 0.866009, 0, 0, 0.347697,-0.0776395) , 
0, 0.345895, 0, 0, 0.5,-5.35251e-06)    );
  // itree = 51
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.544524,0.00191099) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.272482,-0.00866443) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.196765,-0.0234134) , 
2, 0.18007, 0, 0, 0.25354,-0.0493507) , 
9, -0.2681, 0, 0, 0.5,-7.59864e-06)    );
  // itree = 52
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.701671,0.0148296) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.854545,0.0377358) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.473817,-0.00206527) , 
5, 0.984631, 0, 0, 0.480913,-0.00636785) , 
9, 0.303758, 0, 0, 0.5,-1.12155e-05)    );
  // itree = 53
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.546525,0.00286131) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.551929,0.00816962) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.363746,-0.00927348) , 
6, 0.518755, 0, 0, 0.386283,-0.031999) , 
5, 0.786038, 0, 0, 0.5,-4.00578e-06)    );
  // itree = 54
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.549789,0.00477473) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.507651,0.00115048) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.386311,-0.0118376) , 
1, 523.444, 0, 0, 0.456685,-0.0190818) , 
1, 660.283, 0, 0, 0.5,-4.96368e-06)    );
  // itree = 55
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.509751,0.000934906) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.290323,-0.00335775) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.27673,-0.0274969) , 
4, 0.886075, 1, 0, 0.279805,-0.096268) , 
7, 3.03731, 1, 0, 0.5,-5.55532e-06)    );
  // itree = 56
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.512783,0.00184936) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.636,0.00540506) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.386808,-0.0134681) , 
9, 0.256157, 0, 0, 0.428958,-0.0466791) , 
6, 0.119144, 0, 0, 0.5,-6.97738e-06)    );
  // itree = 57
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.650105,0.0087312) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.613969,0.00521768) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.406642,-0.00493949) , 
5, 0.893012, 0, 0, 0.463111,-0.00979444) , 
8, 0.755529, 0, 0, 0.5,-7.07206e-06)    );
  // itree = 58
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.559842,0.00496794) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.8125,0.027181) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.446793,-0.00438889) , 
3, 0.986903, 0, 0, 0.457153,-0.0161929) , 
6, 0.279022, 0, 0, 0.5,-5.22918e-06)    );
  // itree = 59
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.511365,0.001119) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.398773,-0.0095895) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.211957,-0.0322561) , 
2, 0.104629, 0, 0, 0.347697,-0.0680589) , 
0, 0.345895, 0, 0, 0.5,-2.66198e-06)    );
  // itree = 60
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.567288,0.00818183) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.513378,0.000291904) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.382022,-0.0102661) , 
1, 506.27, 0, 0, 0.483247,-0.009348) , 
1, 839.876, 0, 0, 0.5,-4.83539e-06)    );
  // itree = 61
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.526309,0.0019726) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.793651,0.0302836) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.375208,-0.00993239) , 
3, 0.986007, 0, 0, 0.389366,-0.0377887) , 
7, 2.46019, 1, 0, 0.5,-4.97883e-06)    );
  // itree = 62
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.636132,0.0109253) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.590922,0.00354479) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.401056,-0.00522416) , 
5, 0.862448, 0, 0, 0.481146,-0.0068154) , 
6, 0.518839, 0, 0, 0.5,-4.70029e-06)    );
  // itree = 63
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.701671,0.0128973) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.632222,0.00701916) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.442302,-0.00333903) , 
8, 0.746611, 0, 0, 0.480913,-0.00544108) , 
9, 0.303758, 0, 0, 0.5,-3.63244e-06)    );
  // itree = 64
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.534091,0.00131922) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.246523,-0.00842403) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.162455,-0.0264238) , 
7, 2.77156, 1, 0, 0.224719,-0.0489618) , 
9, -0.33164, 0, 0, 0.5,-9.58603e-07)    );
  // itree = 65
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.512783,0.00163112) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.535714,0.00750561) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.412637,-0.0116214) , 
1, 922.217, 0, 0, 0.428958,-0.0408037) , 
6, 0.119144, 0, 0, 0.5,-4.98833e-06)    );
  // itree = 66
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.549789,0.0039765) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.507651,0.000976839) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.386311,-0.00991668) , 
1, 523.444, 0, 0, 0.456685,-0.015733) , 
1, 660.283, 0, 0, 0.5,-4.87164e-06)    );
  // itree = 67
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.511365,0.00102524) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.385172,-0.0102285) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.175,-0.0345279) , 
3, 0.866009, 0, 0, 0.347697,-0.0619894) , 
0, 0.345895, 0, 0, 0.5,-5.2391e-06)    );
  // itree = 68
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.546655,0.00230287) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.566667,0.0294801) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.376594,-0.00684138) , 
4, 0.957483, 0, 0, 0.380778,-0.0266432) , 
3, 0.88886, 0, 0, 0.5,-6.97417e-06)    );
  // itree = 69
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.509751,0.000775246) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.290323,-0.000160036) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.27673,-0.0239543) , 
4, 0.886075, 1, 0, 0.279805,-0.079035) , 
7, 3.03731, 1, 0, 0.5,-7.22731e-06)    );
  // itree = 70
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.856354,0.0314257) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.633218,0.00977276) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.473848,-0.00191556) , 
6, 0.518839, 0, 0, 0.493218,-0.00226843) , 
5, 0.984704, 0, 0, 0.5,-8.15829e-06)    );
  // itree = 71
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.567288,0.00697359) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.539254,0.00146991) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.398967,-0.00685882) , 
2, 0.369061, 0, 0, 0.483247,-0.00789631) , 
1, 839.876, 0, 0, 0.5,-3.31703e-06)    );
  // itree = 72
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.512783,0.00146826) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.540029,-0.00140352) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.332491,-0.0142209) , 
5, 0.847168, 0, 0, 0.428958,-0.0365697) , 
6, 0.119144, 0, 0, 0.5,-3.38736e-06)    );
  // itree = 73
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.701671,0.0114661) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.546512,0.00251483) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.413966,-0.00486544) , 
2, 0.412509, 0, 0, 0.480913,-0.00478142) , 
9, 0.303758, 0, 0, 0.5,-4.28768e-06)    );
  // itree = 74
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.546525,0.0021473) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.458333,-9.00882e-05) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.332714,-0.00956466) , 
1, 688.613, 0, 0, 0.386283,-0.0236399) , 
5, 0.786038, 0, 0, 0.5,-2.81713e-06)    );
  // itree = 75
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.559842,0.00394639) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.511295,0.00121723) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.409091,-0.00657812) , 
1, 658.391, 0, 0, 0.457153,-0.0126874) , 
6, 0.279022, 0, 0, 0.5,-3.79498e-06)    );
  // itree = 76
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.509751,0.000695565) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.309645,-0.0251475) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.252336,-0.00838968) , 
3, 0.916864, 0, 0, 0.279805,-0.0705039) , 
7, 3.03731, 1, 0, 0.5,-3.72313e-06)    );
  // itree = 77
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.536321,0.00193916) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.414392,-0.0028149) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.319756,-0.0173392) , 
5, 0.719597, 0, 0, 0.39585,-0.0249114) , 
4, 0.894567, 0, 0, 0.5,-4.37514e-06)    );
  // itree = 78
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.511365,0.000894871) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.398773,-0.00728804) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.211957,-0.027837) , 
2, 0.104629, 0, 0, 0.347697,-0.0537428) , 
0, 0.345895, 0, 0, 0.5,-5.12411e-06)    );
  // itree = 79
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.505052,0.00045799) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.458333,0.00769109) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.176056,-0.0377277) , 
6, 0.366499, 0, 0, 0.247368,-0.102737) , 
1, 390.893, 0, 0, 0.5,-6.5285e-06)    );
  // itree = 80
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.791209,0.0187721) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.515739,0.00101224) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.375208,-0.00788874) , 
7, 2.46019, 1, 0, 0.488636,-0.00286) , 
3, 0.9861, 0, 0, 0.5,-8.33541e-06)    );
  // itree = 81
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.524182,0.000887035) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.226754,-0.00922857) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.111111,-0.0359921) , 
8, 0.397114, 0, 0, 0.207037,-0.0487297) , 
9, -0.39518, 0, 0, 0.5,-6.08323e-06)    );
  // itree = 82
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.532162,0.00252111) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.519119,0.00234806) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.394774,-0.0091565) , 
1, 671.484, 0, 0, 0.450796,-0.0172098) , 
6, 0.199083, 0, 0, 0.5,-9.1163e-06)    );
  // itree = 83
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.678451,0.00652072) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.619355,0.0132152) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.449832,-0.00239206) , 
2, 0.71664, 0, 0, 0.459798,-0.0064685) , 
9, 0.240218, 0, 0, 0.5,-8.90407e-06)    );
  // itree = 84
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.69226,0.00713564) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.471581,-0.000647494) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.23743,-0.0188659) , 
7, 3.03731, 1, 0, 0.461186,-0.00609623) , 
5, 0.923576, 0, 0, 0.5,-6.73072e-06)    );
  // itree = 85
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.636132,0.00821537) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.867089,0.0295376) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.473848,-0.00158649) , 
5, 0.984704, 0, 0, 0.481146,-0.00501182) , 
6, 0.518839, 0, 0, 0.5,-6.66853e-06)    );
  // itree = 86
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.567288,0.00584495) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.8125,0.036682) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.479818,-0.00187607) , 
9, 0.390457, 0, 0, 0.483247,-0.00655519) , 
1, 839.876, 0, 0, 0.5,-2.81765e-06)    );
  // itree = 87
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.511365,0.000808012) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.440594,-0.0221223) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.307856,-0.00598598) , 
9, 0.0139014, 0, 0, 0.347697,-0.0481801) , 
0, 0.345895, 0, 0, 0.5,-8.86604e-07)    );
  // itree = 88
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.512783,0.00123208) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.471318,-0.012609) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.396158,-0.00201913) , 
7, 1.63579, 1, 0, 0.428958,-0.0303559) , 
6, 0.119144, 0, 0, 0.5,-6.49454e-07)    );
  // itree = 89
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.505052,0.000407406) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.458333,0.00677806) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.176056,-0.0343458) , 
6, 0.366499, 0, 0, 0.247368,-0.0905829) , 
1, 390.893, 0, 0, 0.5,-3.30462e-07)    );
  // itree = 90
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.559331,0.00241562) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.44727,-0.000208027) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.353513,-0.0101054) , 
0, 0.380606, 0, 0, 0.416002,-0.0151776) , 
4, 0.924691, 0, 0, 0.5,-2.44004e-06)    );
  // itree = 91
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.562864,0.00285943) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.569135,0.00494819) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.399257,-0.00526627) , 
4, 0.969876, 0, 0, 0.438216,-0.0126533) , 
7, 1.88306, 1, 0, 0.5,-3.06312e-06)    );
  // itree = 92
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.55827,0.00406655) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.818182,0.0355655) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.470062,-0.00224824) , 
9, 0.390457, 0, 0, 0.47351,-0.0082957) , 
1, 750.079, 0, 0, 0.5,-3.04256e-06)    );
  // itree = 93
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.524182,0.000760557) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.274286,-0.0226784) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.18617,-0.00710716) , 
5, 0.89265, 0, 0, 0.207037,-0.0414783) , 
9, -0.39518, 0, 0, 0.5,-1.43412e-06)    );
  // itree = 94
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.538902,0.00151312) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.410429,-4.52857e-05) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.34622,-0.00984647) , 
4, 0.894567, 0, 0, 0.378666,-0.0210225) , 
5, 0.770756, 0, 0, 0.5,-2.76488e-06)    );
  // itree = 95
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.636132,0.00731304) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.867089,0.0269552) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.473848,-0.00140448) , 
5, 0.984704, 0, 0, 0.481146,-0.00442697) , 
6, 0.518839, 0, 0, 0.5,-3.33597e-06)    );
  // itree = 96
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.701671,0.00877998) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.632222,0.00498371) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.442302,-0.00231109) , 
8, 0.746611, 0, 0, 0.480913,-0.00357059) , 
9, 0.303758, 0, 0, 0.5,-3.48772e-07)    );
  // itree = 97
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.512783,0.00112062) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.471318,-0.0118401) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.396158,-0.00149286) , 
7, 1.63579, 1, 0, 0.428958,-0.0274505) , 
6, 0.119144, 0, 0, 0.5,8.60543e-07)    );
  // itree = 98
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.511365,0.000705631) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.440594,-0.0198308) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.307856,-0.00494841) , 
9, 0.0139014, 0, 0, 0.347697,-0.0418292) , 
0, 0.345895, 0, 0, 0.5,9.77535e-07)    );
  // itree = 99
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.505052,0.000363103) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.458333,0.00608829) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.176056,-0.031381) , 
6, 0.366499, 0, 0, 0.247368,-0.0802588) , 
1, 390.893, 0, 0, 0.5,9.46002e-07)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
